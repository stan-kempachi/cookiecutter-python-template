stages:
  - lint
  - test
  - generate-template
  - cleanup
  - version
  - release

# Lint Stage
lint:
  stage: lint
  image: "python:3.12"
  before_script:
    - pip install pre-commit
  script:
    - pre-commit run --all-files

# Test Stage
test:
  stage: test
  image: "python:3.12"
  before_script:
    - pip install pytest cookiecutter
  script:
    - pytest tests

# Generate Template Stage
generate-template:
  stage: generate-template
  image: "python:3.12"
  before_script:
    - pip install poetry cookiecutter
  script:
    - cookiecutter . --no-input
    - cd mon_super_projet && poetry check

# Cleanup Stage
cleanup:
  stage: cleanup
  image: "alpine:latest"
  script:
    - echo "Cleaning up temporary generated project files."
    - rm -rf mon_super_projet

# Generate Changelog, Tag, and Increment Version
generate_changelog:
  stage: version
  image: "node:lts"
  before_script:
    # SSH and Git configuration
    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git jq -y )'
    - eval $(ssh-agent -s)
    - echo "$CI_SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - ssh-keyscan -H gitlab.com >> ~/.ssh/known_hosts
    - ssh-keyscan -H github.com >> ~/.ssh/known_hosts
    - git init || true
    - git remote add origin "${CI_REPOSITORY_URL}" || echo 'Remote already exists.'
    - git remote add github git@github.com:stan-kempachi/cookiecutter-python-template.git || echo 'GitHub remote already exists.'
    - git fetch --all
    - |
      if [ "${CI_COMMIT_BRANCH}" != "" ]; then
        git checkout -b "${CI_COMMIT_BRANCH}" --track origin/"${CI_COMMIT_BRANCH}" || 
        git checkout "${CI_COMMIT_BRANCH}";
      else
        git checkout -b master --track origin/master || 
        git checkout master;
      fi
    - git remote set-url origin git@gitlab.com:adm.standev/cookiecutter-python-template.git
    - git config --global user.name "${GITLAB_USER_NAME:-ci-user}"
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci-user@gitlab.com}"
    - git fetch --tags
    # Install jq explicitly
    - apt-get update -y && apt-get install jq -y
  script:
    # Environment verification
    - pwd
    - ls -al
    - echo "Current Git remotes:"
    - git remote -v
    - echo "Current branch and status:"
    - git branch
    - git status

    # Display commit history for debugging
    - echo "Last 5 commits:"
    - git log -n 5 --pretty=format:"%h - %s (%an, %ar)"

    # Display current tags
    - echo "Existing tags:"
    - git tag -l

    # Install dependencies
    - npm install

    # Check and fix version if needed
    - |
      if ! jq -e '.version' package.json > /dev/null || [ "$(jq -r '.version' package.json)" = "null" ]; then
        echo "Fixing invalid or missing version in package.json..."
        jq '.version = "1.0.0"' package.json > package.json.tmp && mv package.json.tmp package.json
        git add package.json
        git commit -m "fix: set initial version to 1.0.0" || echo "No changes to commit"
      fi

    # Create empty conventional commit if needed
    - |
      # Check if there are conventional commits
      if ! git log -n 10 --pretty=format:"%s" | grep -E "^(feat|fix|chore|docs|style|refactor|perf|test|build|ci|revert)(\([a-z]+\))?:"; then
        echo "No conventional commits found. Creating empty commit..."
        git commit --allow-empty -m "chore: prepare for new version"
      fi

    # Use --release-as patch instead of auto
    - |
      # First check existing tags and current version
      CURRENT_VERSION=$(jq -r '.version' package.json)
      echo "Current version in package.json: $CURRENT_VERSION"
      
      # Find the highest existing version tag
      HIGHEST_TAG=$(git tag -l "v*" | sort -V | tail -n 1)
      echo "Highest existing tag: $HIGHEST_TAG"
      
      if [ -n "$HIGHEST_TAG" ]; then
        # Remove 'v' prefix if present
        HIGHEST_VERSION=${HIGHEST_TAG#v}
        
        # Compare versions and determine next version
        MAJOR=$(echo $HIGHEST_VERSION | cut -d. -f1)
        MINOR=$(echo $HIGHEST_VERSION | cut -d. -f2)
        PATCH=$(echo $HIGHEST_VERSION | cut -d. -f3)
        
        # Calculate next patch version
        NEXT_PATCH=$((PATCH + 1))
        NEXT_VERSION="$MAJOR.$MINOR.$NEXT_PATCH"
        
        echo "Calculated next version: $NEXT_VERSION"
        
        # Update package.json and package-lock.json with the new version
        jq ".version = \"$NEXT_VERSION\"" package.json > tmp.$$ && mv tmp.$$ package.json
        if [ -f "package-lock.json" ]; then
          jq ".version = \"$NEXT_VERSION\"" package-lock.json > tmp.$$ && mv tmp.$$ package-lock.json
        fi
        
        # Generate changelog manually
        echo "Generating changelog for version $NEXT_VERSION"
        npx standard-version --skip.bump --skip.tag --skip.commit --release-as $NEXT_VERSION
        
        # Commit changes
        git add package.json package-lock.json CHANGELOG.md
        git commit -m "chore(release): $NEXT_VERSION"
        
        # Create new tag
        git tag -a "v$NEXT_VERSION" -m "chore(release): $NEXT_VERSION"
      else
        # No tags exist, use standard-version normally
        echo "No existing version tags found. Creating initial version..."
        npx standard-version --release-as patch
      fi

    # Verify that version was properly generated
    - |
      NEW_VERSION=$(jq -r '.version' package.json)
      if [ "$NEW_VERSION" = "null" ] || [ -z "$NEW_VERSION" ]; then
        echo "Error: Invalid version generated"
        git reset --hard
        exit 1
      else
        echo "Successfully generated version: $NEW_VERSION"
      fi

    # Display new version and push changes
    - |
      export VERSION=$(jq -r '.version' package.json)
      echo "New version: $VERSION"
      echo "Pushing changes and tags to remote repositories..."
      git push origin HEAD:${CI_COMMIT_BRANCH} --follow-tags
      git push github HEAD:${CI_COMMIT_BRANCH} --follow-tags || echo "Failed to push to GitHub (this is not critical)"

# Release Stage
release:
  stage: release
  image: "node:lts"
  script:
    - echo "Deployment in progress..."
  rules:
    - if: $CI_COMMIT_TAG != null