# Définition des règles globales
.default_rules:
  rules:
    - if: '$CI_COMMIT_BRANCH == "version-lock"'
      when: never
    - when: always

stages:
  - lint
  - test
  - generate-template
  - cleanup
  - version
  - release

# Lint Stage
lint:
  stage: lint
  image: "python:3.12"
  rules:
    - !reference [.default_rules, rules]
  before_script:
    - pip install pre-commit
  script:
    - pre-commit run --all-files

# Test Stage
test:
  stage: test
  image: "python:3.12"
  rules:
    - !reference [.default_rules, rules]
  before_script:
    - pip install pytest cookiecutter
  script:
    - pytest tests

# Generate Template Stage
generate-template:
  stage: generate-template
  image: "python:3.12"
  rules:
    - !reference [.default_rules, rules]
  before_script:
    - pip install poetry cookiecutter
  script:
    - cookiecutter . --no-input
    - cd mon_super_projet && poetry check

# Cleanup Stage
cleanup:
  stage: cleanup
  image: "alpine:latest"
  rules:
    - !reference [.default_rules, rules]
  script:
    - echo "Cleaning up temporary generated project files."
    - rm -rf mon_super_projet

# Generate Changelog, Tag, and Increment Version
generate_changelog:
  stage: version
  image: "node:lts"
  # Conditions pour éviter les boucles infinies
  rules:
    - if: '$CI_COMMIT_BRANCH == "version-lock"'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ /\[skip ci\]/ || $CI_COMMIT_MESSAGE =~ /chore\(release\)/'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"'
      when: always
  before_script:
    # Installation des outils nécessaires
    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git jq -y )'
    - eval $(ssh-agent -s)

    # Configuration SSH et Git sécurisée
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$CI_SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-add ~/.ssh/id_rsa
    - ssh-keyscan -H gitlab.com >> ~/.ssh/known_hosts
    - ssh-keyscan -H github.com >> ~/.ssh/known_hosts

    # Configuration Git améliorée
    - git config --global user.name "${GITLAB_USER_NAME:-CI Bot}"
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci-bot@example.com}"

    # Initialisation du dépôt et configuration des remotes
    - git init || true
    - git remote add origin "${CI_REPOSITORY_URL}" || echo 'Remote already exists.'
    - git remote add github git@github.com:stan-kempachi/cookiecutter-python-template.git || echo 'GitHub remote already exists.'
    - git remote set-url origin git@gitlab.com:adm.standev/cookiecutter-python-template.git

    # Récupération complète des données de tous les dépôts distants
    - git fetch --all --tags --prune --force

    # Checkout de la branche actuelle avec synchronisation
    - |
      if [ "${CI_COMMIT_BRANCH}" != "" ]; then
        git checkout -B "${CI_COMMIT_BRANCH}" "origin/${CI_COMMIT_BRANCH}"
      else
        git checkout -B master origin/master
      fi

    # Vérification de la synchronisation entre GitHub et GitLab
    - |
      echo "Vérification de la synchronisation des dépôts..."
      GITLAB_HEAD=$(git rev-parse HEAD)
      git fetch github
      
      # Tentative de récupération de la HEAD de GitHub
      if git rev-parse github/${CI_COMMIT_BRANCH} &>/dev/null; then
        GITHUB_HEAD=$(git rev-parse github/${CI_COMMIT_BRANCH})
      
        if [ "$GITLAB_HEAD" != "$GITHUB_HEAD" ]; then
          echo "Les dépôts ne sont pas synchronisés!"
          echo "GitLab HEAD: $GITLAB_HEAD"
          echo "GitHub HEAD: $GITHUB_HEAD"
      
          # Si GitHub est en avance, on synchronise GitLab
          if git merge-base --is-ancestor $GITLAB_HEAD $GITHUB_HEAD; then
            echo "GitHub est en avance, on synchronise GitLab..."
            git merge github/${CI_COMMIT_BRANCH} --no-edit -m "chore: synchroniser avec GitHub [skip ci]"
            git push origin ${CI_COMMIT_BRANCH}
          # Si GitLab est en avance, on synchronise GitHub (sera fait plus tard)
          else
            echo "GitLab est en avance, GitHub sera synchronisé après le versionnement"
          fi
        else
          echo "Les dépôts sont synchronisés"
        fi
      else
        echo "La branche ${CI_COMMIT_BRANCH} n'existe pas sur GitHub, elle sera créée"
      fi

    # Installation des dépendances Node.js
    - npm ci || npm install

  script:
    # Vérification de la cohérence des versions
    - echo "Vérification de la version dans package.json"
    - PKG_VERSION=$(jq -r .version package.json)
    - |
      echo "Version dans package.json: $PKG_VERSION"

    # Vérification de package-lock.json
    - echo "Vérification de la version dans package-lock.json"
    - LOCK_VERSION=$(jq -r .version package-lock.json)
    - LOCK_PKG_VERSION=$(jq -r '.packages."".version' package-lock.json)
    - |
      echo "Version dans package-lock.json header: $LOCK_VERSION"
    - |
      echo "Version dans package-lock.json packages: $LOCK_PKG_VERSION"

    # Correction si nécessaire
    - |
      if [ "$PKG_VERSION" != "$LOCK_VERSION" ] || [ "$PKG_VERSION" != "$LOCK_PKG_VERSION" ]; then
        echo "Incohérence détectée dans les versions. Mise à jour du package-lock.json..."
        npm install --package-lock-only
        git add package-lock.json
        git commit -m "fix: corriger l'incohérence de version dans package-lock.json [skip ci]"
      fi

    # Exécution de standard-version avec options explicites
    - |
      echo "Exécution de standard-version pour créer une nouvelle version..."
      npx standard-version --release-as patch

    # Récupération de la nouvelle version
    - NEW_VERSION=$(jq -r .version package.json)
    - |
      echo "Nouvelle version: $NEW_VERSION"

    # Push vers GitLab
    - |
      git push --follow-tags origin ${CI_COMMIT_BRANCH}

    # Push vers GitHub
    - |
      echo "Synchronisation avec GitHub..."
      if git rev-parse github/${CI_COMMIT_BRANCH} &>/dev/null; then
        echo "Mise à jour de la branche existante sur GitHub"
        git push --follow-tags github ${CI_COMMIT_BRANCH}
      else
        echo "Création de la branche sur GitHub"
        git push --follow-tags github ${CI_COMMIT_BRANCH}
      fi

# Release Stage - création des artifacts
release:
  stage: release
  image: "python:3.12"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: always
  script:
    - echo "Version $CI_COMMIT_TAG est maintenant publiée!"
    - echo "Création des artifacts pour la version $CI_COMMIT_TAG"
    # Vous pouvez ajouter ici des étapes pour créer des archives, des binaires, etc.
  artifacts:
    paths:
      - "{{cookiecutter.project_slug}}/"
    expire_in: 1 week