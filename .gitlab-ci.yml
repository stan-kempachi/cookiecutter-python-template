# Définition des règles globales
.default_rules:
  rules:
    - if: '$CI_COMMIT_BRANCH == "version-lock"'
      when: never
    - when: always

stages:
  - lint
  - test
  - generate-template
  - cleanup
  - version
  - release

# Lint Stage
lint:
  stage: lint
  image: "python:3.12"
  rules:
    - !reference [.default_rules, rules]
  before_script:
    - pip install pre-commit
  script:
    - pre-commit run --all-files

# Test Stage
test:
  stage: test
  image: "python:3.12"
  rules:
    - !reference [.default_rules, rules]
  before_script:
    - pip install pytest cookiecutter
  script:
    - pytest tests

# Generate Template Stage
generate-template:
  stage: generate-template
  image: "python:3.12"
  rules:
    - !reference [.default_rules, rules]
  before_script:
    - pip install poetry cookiecutter
  script:
    - cookiecutter . --no-input
    - cd mon_super_projet && poetry check

# Cleanup Stage
cleanup:
  stage: cleanup
  image: "alpine:latest"
  rules:
    - !reference [.default_rules, rules]
  script:
    - echo "Cleaning up temporary generated project files."
    - rm -rf mon_super_projet

# Generate Changelog, Tag, and Increment Version
generate_changelog:
  stage: version
  image: "node:lts"
  # Conditions to avoid infinite loops
  rules:
    - if: '$CI_COMMIT_BRANCH == "version-lock"'
      when: never
    - if: '$CI_COMMIT_MESSAGE =~ /\[skip ci\]/ || $CI_COMMIT_MESSAGE =~ /chore\(release\)/'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: always
    - if: '$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "main"'
      when: always
  before_script:
    # Install required tools
    - |
      which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )
    # Explicitly install jq
    - |
      apt-get update -y && apt-get install jq -y
    - |
      eval $(ssh-agent -s)

    # Secure SSH and Git configuration
    - |
      mkdir -p ~/.ssh
      chmod 700 ~/.ssh
      echo "$CI_SSH_KEY" | tr -d '\r' > ~/.ssh/id_rsa
      chmod 600 ~/.ssh/id_rsa
      ssh-add ~/.ssh/id_rsa
      ssh-keyscan -H gitlab.com >> ~/.ssh/known_hosts
      ssh-keyscan -H github.com >> ~/.ssh/known_hosts

    # Enhanced Git configuration
    - |
      git config --global user.name "${GITLAB_USER_NAME:-CI Bot}"
      git config --global user.email "${GITLAB_USER_EMAIL:-ci-bot@example.com}"

    # Repository initialization and remote configuration
    - |
      git init || true
      git remote add origin "${CI_REPOSITORY_URL}" || echo 'Remote already exists.'
      git remote add github git@github.com:stan-kempachi/cookiecutter-python-template.git || echo 'GitHub remote already exists.'
      git remote set-url origin git@gitlab.com:adm.standev/cookiecutter-python-template.git

    # Complete fetch of all remote repositories data
    - |
      git fetch --all --tags --prune --force

    # Checkout current branch with synchronization
    - |
      if [ "${CI_COMMIT_BRANCH}" != "" ]; then
        git checkout -B "${CI_COMMIT_BRANCH}" "origin/${CI_COMMIT_BRANCH}"
      else
        git checkout -B master origin/master
      fi

    # Check synchronization between GitHub and GitLab
    - |
      echo "Checking repository synchronization..."
      GITLAB_HEAD=$(git rev-parse HEAD)
      git fetch github
      
      # Try to get GitHub HEAD
      if git rev-parse github/${CI_COMMIT_BRANCH} &>/dev/null; then
        GITHUB_HEAD=$(git rev-parse github/${CI_COMMIT_BRANCH})
      
        if [ "$GITLAB_HEAD" != "$GITHUB_HEAD" ]; then
          echo "Repositories are not synchronized!"
          echo "GitLab HEAD: $GITLAB_HEAD"
          echo "GitHub HEAD: $GITHUB_HEAD"
      
          # If GitHub is ahead, synchronize GitLab
          if git merge-base --is-ancestor $GITLAB_HEAD $GITHUB_HEAD; then
            echo "GitHub is ahead, synchronizing GitLab..."
            git merge github/${CI_COMMIT_BRANCH} --no-edit -m "chore: synchronize with GitHub [skip ci]"
            git push origin ${CI_COMMIT_BRANCH}
          # If GitLab is ahead, GitHub will be synchronized later
          else
            echo "GitLab is ahead, GitHub will be synchronized after versioning"
          fi
        else
          echo "Repositories are synchronized"
        fi
      else
        echo "Branch ${CI_COMMIT_BRANCH} doesn't exist on GitHub, it will be created"
      fi

    # Install Node.js dependencies
    - |
      npm ci || npm install

  script:
    # Clean up problematic tags
    - |
      echo "Cleaning up problematic tags containing 'null'..."
      NULL_TAGS=$(git tag | grep "null" || echo "")
      if [ -n "$NULL_TAGS" ]; then
        echo "Found problematic tags: $NULL_TAGS"
      
        # Local deletion
        echo "Deleting tags locally..."
        git tag | grep "null" | xargs git tag -d
      
        # GitLab deletion
        echo "Deleting tags on GitLab..."
        for tag in $NULL_TAGS; do
          git push origin :refs/tags/$tag || echo "Error while deleting tag $tag on GitLab"
        done
      
        # GitHub deletion
        echo "Deleting tags on GitHub..."
        for tag in $NULL_TAGS; do
          git push github :refs/tags/$tag || echo "Error while deleting tag $tag on GitHub"
        done
      
        echo "Tag cleanup completed."
      else
        echo "No problematic tags found."
      fi

    # Check and fix version in package.json
    - |
      echo "Checking version in package.json"
      PKG_VERSION=$(jq -r .version package.json)
      echo "Current version in package.json: $PKG_VERSION"
      
      if [[ "$PKG_VERSION" == "null"* || "$PKG_VERSION" == "" ]]; then
        echo "Invalid version detected, fixing to 1.0.0"
        # Determine appropriate version
        # Option 1: Use 1.0.0 as default value
        NEW_VERSION="1.0.0"
      
        # Option 2: Extract version from package-lock.json if available
        LOCK_VERSION=$(jq -r '.packages[""].version' package-lock.json 2>/dev/null || echo "")
        if [[ "$LOCK_VERSION" != "null"* && "$LOCK_VERSION" != "" ]]; then
          NEW_VERSION="$LOCK_VERSION"
          echo "Using version $NEW_VERSION from package-lock.json"
        fi
      
        # Update package.json
        jq --arg ver "$NEW_VERSION" '.version = $ver' package.json > package.json.tmp
        mv package.json.tmp package.json
        echo "Version fixed to $NEW_VERSION in package.json"
      
        # Commit the fix
        git add package.json
        git commit -m "fix: correct invalid version in package.json [skip ci]"
      fi

    # Run standard-version to generate new version
    - |
      echo "Running standard-version to create a new version..."
      npx standard-version

    # Get the new version
    - |
      NEW_TAG=$(git describe --tags --abbrev=0)
      echo "New version created: $NEW_TAG"

    # Push to GitLab
    - |
      echo "Pushing changes to GitLab..."
      git push origin ${CI_COMMIT_BRANCH} --follow-tags

    # Push to GitHub
    - |
      echo "Pushing changes to GitHub..."
      git push github ${CI_COMMIT_BRANCH} --follow-tags

  artifacts:
    paths:
      - CHANGELOG.md
    expire_in: 1 week

# Release Stage - création des artifacts
release:
  stage: release
  image: "python:3.12"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: always
  script:
    - echo "Version $CI_COMMIT_TAG est maintenant publiée!"
    - echo "Création des artifacts pour la version $CI_COMMIT_TAG"
    # Vous pouvez ajouter ici des étapes pour créer des archives, des binaires, etc.
  artifacts:
    paths:
      - "{{cookiecutter.project_slug}}/"
    expire_in: 1 week